\abstract

\textbf{Background} Since the introduction of second generation sequencing technologies, improving assembly efficiency has been an important effort to match the high-throughput of sequencing. One bottleneck in the assembly process is memory needed to represent a \dBG, a structure that is prevalent and essential in modern assemblers. One aspect of improving this representation is finding a memory-efficient way of representing a set of $k$-long strings, called \kmers. Another is filtering the sequencing reads generated by the sequencers to avoid inserting nodes in the \dBG representing read errors.

\textbf{Aims} In this work we propose a pipeline based on two new representations of the \dBG which aims at filtering \kmer{s} obtained from the reads based on frequency and connectivity to other \kmer{s}, and representing only high-quality \kmer{s} in a succint manner.

\textbf{Results} We show that \dBCM, a \cm{-based} representation can be used to effectively filter over $80\%$ of spurious \kmer{s} from the reads based on count alone, and can then be traversed to further remove erroneous \kmer{s} based on connectivity, filtering over $95\%$ of spurious \kmer{s} in total. We then represent the remaining \kmer{s} in a \dBHT, a hashtable-based probabilistic representation of the \dBG that requires between $9$ and $16$~bits per \kmer, while allowing for contant time insertion and query. We show that even with $9$ bits per \kmer, the number of false positive \kmer{s} is still less than $16\%$ of the total graph.

\textbf{Conclusion} We show that connectivity-based filtering through traversal is very effective in filtering spurious \kmer{s} from the reads beyond frequency-based filtering and can efficiently be done by the \dBCM. We also show that we can achieve a very good compromise of memory usage and insertion and query time with the \dBHT by using only a single hashing function.

\begin{keywords}
\dBG, \kmer, genome assembly, sequencing, filtering, sketching
\end{keywords}