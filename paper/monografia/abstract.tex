\abstract

\textbf{Background} Since the introduction of the second generation of genome sequencing technologies, improving assembly efficiency has become critical to match the high-throughput of data. A major bottleneck is the memory needed to represent \dBG{s}, an essential structure in modern assemblers. Improving this representation involves finding a memory-efficient way of representing a set of \kmers, which are sequences of a fixed length $k$, as well as filtering out sequencing errors from the input reads generated by the sequencers.

\textbf{Objectives} In this work we address these two problems to develop a \dBG representation that faithfully represents the \kmers in the sequenced genome while leaving out spurious parts affected by sequencing errors. Not only we want out representation to have a good sensitivity to specificity ratio, but we also strive to make it space and time-efficient.

\textbf{Methods} We propose and implement a pipeline based on two new representations of the \dBG which aims at filtering \kmer{s} obtained from the reads based on frequency and connectivity to other \kmer{s}, and representing only high-quality \kmer{s} in a succint manner. We then applied out method to a realistic dataset based on a microbial genome.

\textbf{Results} We show that \dBCM, a \cm{-based} representation can be used to effectively filter over $80\%$ of spurious \kmer{s} from the reads based on count alone, and can then be traversed to further remove erroneous \kmer{s} based on connectivity, filtering over $95\%$ of spurious \kmer{s} in total. We then represent the remaining \kmer{s} in a \dBHT, a hashtable-based probabilistic representation of the \dBG that requires between $9$ and $16$~bits per \kmer, while allowing for constant time insertion and query. We show that even with $9$ bits per \kmer, the number of false positive \kmer{s} is still less than $16\%$ of the total graph.

\textbf{Conclusion} We show that connectivity-based filtering through traversal is very effective in filtering spurious \kmer{s} from the reads beyond frequency-based filtering and can efficiently be done by the \dBCM. We also show that we can achieve a very good compromise of memory usage and insertion and query time with the \dBHT by using a single hashing function.

\begin{keywords}
\dBG, \kmer, genome assembly, sequencing, filtering, sketch, \cm, Hashtable
\end{keywords}