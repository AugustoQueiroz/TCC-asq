@article{Cormode2005,
   abstract = {We introduce a new sublinear space data structure - the count-min sketch - for summarizing data streams. Our sketch allows fundamental queries in data stream summarization such as point, range, and inner product queries to be approximately answered very quickly; in addition, it can be applied to solve several important problems in data streams such as finding quantiles, frequent items, etc. The time and space bounds we show for using the CM sketch to solve these problems significantly improve those previously known - typically from 1/ε2 to 1/ε in factor. © 2003 Elsevier Inc. All rights reserved.},
   author = {Graham Cormode and S. Muthukrishnan},
   doi = {10.1016/j.jalgor.2003.12.001},
   issn = {01966774},
   issue = {1},
   journal = {Journal of Algorithms},
   month = {4},
   pages = {58-75},
   title = {An improved data stream summary: The count-min sketch and its applications},
   volume = {55},
   year = {2005},
}

@article{Conway2011,
   abstract = {Motivation: Second-generation sequencing technology makes it feasible for many researches to obtain enough sequence reads to attempt the de novo assembly of higher eukaryotes (including mammals). De novo assembly not only provides a tool for understanding wide scale biological variation, but within human biomedicine, it offers a direct way of observing both large-scale structural variation and fine-scale sequence variation. Unfortunately, improvements in the computational feasibility for de novo assembly have not matched the improvements in the gathering of sequence data. This is for two reasons: the inherent computational complexity of the problem and the in-practice memory requirements of tools. Results: In this article, we use entropy compressed or succinct data structures to create a practical representation of the de Bruijn assembly graph, which requires at least a factor of 10 less storage than the kinds of structures used by deployed methods. Moreover, because our representation is entropy compressed, in the presence of sequencing errors it has better scaling behaviour asymptotically than conventional approaches. We present results of a proof-of-concept assembly of a human genome performed on a modest commodity server. © The Author 2011. Published by Oxford University Press. All rights reserved.},
   author = {Thomas C. Conway and Andrew J. Bromage},
   doi = {10.1093/bioinformatics/btq697},
   issn = {13674803},
   issue = {4},
   journal = {Bioinformatics},
   month = {2},
   pages = {479-486},
   pmid = {21245053},
   title = {Succinct data structures for assembling large genomes},
   volume = {27},
   year = {2011},
}

@article{Chikhi2014,
   abstract = {The de Bruijn graph plays an important role in bioinformatics, especially in the context of de novo assembly. However, the representation of the de Bruijn graph in memory is a computational bottleneck for many assemblers. Recent papers proposed a navigational data structure approach in order to improve memory usage. We prove several theoretical space lower bounds to show the limitation of these types of approaches. We further design and implement a general data structure (DBGFM) and demonstrate its use on a human whole-genome dataset, achieving space usage of 1.5 GB and a 46% improvement over previous approaches. As part of DBGFM, we develop the notion of frequency-based minimizers and show how it can be used to enumerate all maximal simple paths of the de Bruijn graph using only 43 MB of memory. Finally, we demonstrate that our approach can be integrated into an existing assembler by modifying the ABySS software to use DBGFM.},
   author = {Rayan Chikhi and Antoine Limasset and Shaun Jackman and Jared Simpson and Paul Medvedev},
   month = {1},
   title = {On the representation of de Bruijn graphs},
   url = {http://arxiv.org/abs/1401.5383},
   year = {2014},
}

@article{Leinonen2011,
   abstract = {The combination of significantly lower cost and increased speed of sequencing has resulted in an explosive growth of data submitted into the primary next-generation sequence data archive, the Sequence Read Archive (SRA). The preservation of experimental data is an important part of the scientific record, and increasing numbers of journals and funding agencies require that next-generation sequence data are deposited into the SRA. The SRA was established as a public repository for the next-generation sequence data and is operated by the International Nucleotide Sequence Database Collaboration (INSDC). INSDC partners include the National Center for Biotechnology Information (NCBI), the European Bioinformatics Institute (EBI) and the DNA Data Bank of Japan (DDBJ). The SRA is accessible at http://www.ncbi.nlm.nih.gov/Traces/sra from NCBI, at http://www.ebi.ac.uk/ena from EBI and at http://trace.ddbj.nig.ac.jp from DDBJ. In this article, we present the content and structure of the SRA, detail our support for sequencing platforms and provide recommended data submission levels and formats. We also briefly outline our response to the challenge of data growth.},
   author = {Rasko Leinonen and Hideaki Sugawara and Martin Shumway and International Nucleotide Sequence Database Collaboration},
   doi = {10.1093/nar/gkq1019},
   edition = {2010/11/09},
   issn = {1362-4962},
   issue = {Database issue},
   journal = {Nucleic acids research},
   keywords = {*Databases, Nucleic Acid,*High-Throughput Nucleotide Sequencing},
   month = {1},
   pages = {D19-D21},
   pmid = {21062823},
   publisher = {Oxford University Press},
   title = {The sequence read archive},
   volume = {39},
   url = {https://pubmed.ncbi.nlm.nih.gov/21062823 https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3013647/},
   year = {2011},
}

@article{Ghosh2019,
   abstract = {De novo genome assembly describes the process of reconstructing an unknown genome from a large collection of short or long reads sequenced from the genome. A single run of a Next-Generation Sequencing NGS technology can produce billions of short reads, making genome assembly computationally demanding both in terms of memory and time. One of the major computational steps in modern day short read assemblers involves the construction and use of a string data structure called the de Bruijn graph. In fact, a majority of short read assemblers build the complete de Bruijn graph for the set of input reads, and subsequently traverse and prune low-quality edges, in order to generate genomic "contigs"-the output of assembly. These steps of graph construction and traversal, contribute to well over 90 percent of the runtime and memory. In this paper, we present a fast algorithm, FastEtch, that uses sketching to build an approximate version of the de Bruijn graph for the purpose of generating an assembly. The algorithm uses Count-Min sketch, which is a probabilistic data structure for streaming data sets. The result is an approximate de Bruijn graph that stores information pertaining only to a selected subset of nodes that are most likely to contribute to the contig generation step. In addition, edges are not stored; instead that fraction which contribute to our contig generation are detected on-the-fly. This approximate approach is intended to significantly improve performance both execution time and memory footprint whilst possibly compromising on the output assembly quality. We present two main versions of the assembler-one that generates an assembly, where each contig represents a contiguous genomic region from one strand of the DNA, and another that generates an assembly, where the contigs can straddle either of the two strands of the DNA. For further scalability, we have implemented a multi-threaded parallel code. Experimental results using our algorithm conducted on E. coli, Yeast, C. elegans, and Human Chr2 and Chr2+3 genomes show that our method yields one of the best time-memory-quality trade-offs, when compared against many state-of-the-art genome assemblers.},
   author = {Priyanka Ghosh and Ananth Kalyanaraman},
   doi = {10.1109/TCBB.2017.2737999},
   issn = {15579964},
   issue = {4},
   journal = {IEEE/ACM Transactions on Computational Biology and Bioinformatics},
   keywords = {Approximation methods,Count-min sketch,De Bruijn graph,Genome assembly},
   month = {7},
   pages = {1091-1106},
   pmid = {28910776},
   publisher = {Institute of Electrical and Electronics Engineers Inc.},
   title = {FastEtch: A fast sketch-based assembler for genomes},
   volume = {16},
   year = {2019},
}

@article{Zhang2014,
   abstract = {K-mer abundance analysis is widely used for many purposes in nucleotide sequence analysis, including data preprocessing for de novo assembly, repeat detection, and sequencing coverage estimation. We present the khmer software package for fast and memory efficient online counting of k-mers in sequencing data sets. Unlike previous methods based on data structures such as hash tables, suffix arrays, and trie structures, khmer relies entirely on a simple probabilistic data structure, a Count-Min Sketch. The Count-Min Sketch permits online updating and retrieval of k-mer counts in memory which is necessary to support online k-mer analysis algorithms. On sparse data sets this data structure is considerably more memory efficient than any exact data structure. In exchange, the use of a Count-Min Sketch introduces a systematic overcount for kmers; moreover, only the counts, and not the k-mers, are stored. Here we analyze the speed, the memory usage, and the miscount rate of khmer for generating k-mer frequency distributions and retrieving k-mer counts for individual k-mers. We also compare the performance of khmer to several other k-mer counting packages, including Tallymer, Jellyfish, BFCounter, DSK, KMC, Turtle and KAnalyze. Finally, we examine the effectiveness of profiling sequencing error, k-mer abundance trimming, and digital normalization of reads in the context of high khmer false positive rates. khmer is implemented in C++ wrapped in a Python interface, offers a tested and robust API, and is freely available under the BSD license at github.com/ged-lab/khmer. © 2014 Zhang et al.},
   author = {Qingpeng Zhang and Jason Pell and Rosangela Canino-Koning and Adina Chuang Howe and C. Titus Brown},
   doi = {10.1371/journal.pone.0101271},
   issn = {19326203},
   issue = {7},
   journal = {PLoS ONE},
   month = {7},
   pmid = {25062443},
   publisher = {Public Library of Science},
   title = {These are not the K-mers you are looking for: Efficient online K-mer counting using a probabilistic data structure},
   volume = {9},
   year = {2014},
}

@article{Pevzner2001,
doi = {10.1073/pnas.171285098},
author = {Pavel A. Pevzner  and Haixu Tang  and Michael S. Waterman },
title = {An Eulerian path approach to DNA fragment assembly},
journal = {Proceedings of the National Academy of Sciences},
volume = {98},
number = {17},
pages = {9748-9753},
year = {2001},
doi = {10.1073/pnas.171285098},
URL = {https://www.pnas.org/doi/abs/10.1073/pnas.171285098},
eprint = {https://www.pnas.org/doi/pdf/10.1073/pnas.171285098},
abstract = {For the last 20 years, fragment assembly in DNA sequencing
 followed the “overlap–layout–consensus” paradigm that is used
 in all currently available assembly tools. Although this approach
 proved useful in assembling clones, it faces difficulties in genomic
 shotgun assembly. We abandon the classical
 “overlap–layout–consensus” approach in favor of a new
 euler algorithm that, for the first time, resolves the
 20-year-old “repeat problem” in fragment assembly. Our main
 result is the reduction of the fragment assembly to a variation of the
 classical Eulerian path problem that allows one to generate accurate
 solutions of large-scale sequencing problems. euler, in
 contrast to the celera assembler, does not mask such
 repeats but uses them instead as a powerful fragment assembly tool.}
}

@article{Pell2012,
   abstract = {Deep sequencing has enabled the investigation of a wide range of environmental microbial ecosystems, but the high memory requirements for de novo assembly of short-read shotgun sequencing data from these complex populations are an increasingly large practical barrier. Here we introduce a memory-efficient graph representation with which we can analyze the k-mer connectivity of metagenomic samples. The graph representation is based on a probabilistic data structure, a Bloom filter, that allows us to efficiently store assembly graphs in as little as 4 bits per k-mer, albeit inexactly. We show that this data structure accurately represents DNA assembly graphs in low memory. We apply this data structure to the problem of partitioning assembly graphs into components as a prelude to assembly, and show that this reduces the overall memory requirements for de novo assembly of metagenomes. On one soil metagenome assembly, this approach achieves a nearly 40-fold decrease in the maximum memory requirements for assembly. This probabilistic graph representation is a significant theoretical advance in storing assembly graphs and also yields immediate leverage on metagenomic assembly.},
   author = {Jason Pell and Arend Hintze and Rosangela Canino-Koning and Adina Howe and James M Tiedje and C Titus Brown},
   doi = {10.1073/pnas.1121464109},
   issue = {33},
   journal = {Proceedings of the National Academy of Sciences},
   pages = {13272-13277},
   title = {Scaling metagenome sequence assembly with probabilistic de Bruijn graphs},
   volume = {109},
   url = {https://www.pnas.org/doi/abs/10.1073/pnas.1121464109},
   year = {2012},
}

@report{Chikhi2013,
   abstract = {Background: The de Bruijn graph data structure is widely used in next-generation sequencing (NGS). Many programs, e.g. de novo assemblers, rely on in-memory representation of this graph. However, current techniques for representing the de Bruijn graph of a human genome require a large amount of memory (≥ 30 GB). Results: We propose a new encoding of the de Bruijn graph, which occupies an order of magnitude less space than current representations. The encoding is based on a Bloom filter, with an additional structure to remove critical false positives. Conclusions: An assembly software implementing this structure, Minia, performed a complete de novo assembly of human genome short reads using 5.7 GB of memory in 23 hours.},
   author = {Rayan Chikhi and Guillaume Rizk},
   journal = {Algorithms for Molecular Biology},
   keywords = {Bloom filter,de Bruijn graph,de novo assembly},
   pages = {22},
   title = {Space-efficient and exact de Bruijn graph representation based on a Bloom filter},
   volume = {8},
   url = {http://www.almob.org/content/8/1/22},
   year = {2013},
}

@inproceedings{Bowe2012,
  title={Succinct de Bruijn graphs},
  author={Bowe, Alexander and Onodera, Taku and Sadakane, Kunihiko and Shibuya, Tetsuo},
  booktitle={International workshop on algorithms in bioinformatics},
  pages={225--235},
  year={2012},
  organization={Springer}
}

@article{Chikhi2019,
  author = {Chikhi, Rayan and Holub, Jan and Medvedev, Paul},
  title = {Data Structures to Represent a Set of k-Long DNA Sequences},
  year = {2021},
  issue_date = {January 2022},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {54},
  number = {1},
  issn = {0360-0300},
  url = {https://doi.org/10.1145/3445967},
  doi = {10.1145/3445967},
  abstract = {The analysis of biological sequencing data has been one of the biggest applications of string algorithms. The approaches used in many such applications are based on the analysis of k-mers, which are short fixed-length strings present in a dataset. While these approaches are rather diverse, storing and querying a k-mer set has emerged as a shared underlying component. A set of k-mers has unique features and applications that, over the past 10 years, have resulted in many specialized approaches for its representation. In this survey, we give a unified presentation and comparison of the data structures that have been proposed to store and query a k-mer set. We hope this survey will serve as a resource for researchers in the field as well as make the area more accessible to researchers outside the field.},
  journal = {ACM Comput. Surv.},
  month = {mar},
  articleno = {17},
  numpages = {22},
  keywords = {Bloom filters, unitgs, data structures, k-mers, FM-index, navigational data structures, de Bruijn graphs, biological sequencing data, k-mer sets}
}